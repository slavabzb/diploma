\subsection{Решение задачи оптимизации большой размерности}

Покажем приложение созданной реализации алгоритма метода эллипсоидов к решению оптимизационной задачи большой размерности.

Рассмотрим задачу минимизации
\begin{equation}
\label{eq:LargeProblem}
f_0(x_1,x_2,\ldots,x_n)=\sum_{i=1}^nx_i^2\rightarrow\min,
\end{equation}

\noindent при ограничениях

\begin{equation}
\label{eq:LargeProblemConstraints}
f_m(x_1,x_2,\ldots,x_n)=\sum_{i=1,i\neq m}^nx_i^2+(x_m-\alpha/2)^2-\alpha^2,\;m=\overline{1,n}.
\end{equation}

Все функции $f_\nu,\;\nu=\overline{0,n}$ определены на $E^n$. Целевая функция~(\ref{eq:LargeProblem}) представляет собой $n$-мерную параболу с вершиной в нуле, а каждое из ограничений~(\ref{eq:LargeProblemConstraints}) -- это $n$-мерный шар радиуса $\alpha$, смещенный по одной из осей на $\alpha/2$.

Ясно, что рассматриваемая задача оптимизации при данных ограничениях имеет оптимум в начале координат. Этот пример рассматривается исключительно как тестовый. Выбор именно такой формы целевой функции и ограничений обуславливается простотой их процедурной генерации.

Решим задачу~(\ref{eq:LargeProblem})--(\ref{eq:LargeProblemConstraints}) численно. Рассмотрим случай $n=100,\;\alpha=1$. Субградиент целевой функции $$g_0(x_1,x_2,\ldots,x_n)=(2x_1,2x_2,\ldots,2x_n),$$ субградиенты ограничений $$g_m(x_1,x_2,\ldots,x_n)=(2x_1,\ldots,2x_{m-1},2(x_m-\alpha/2),2x_{m+1},\ldots,2x_n).$$

Положим начальную точку $x_0=(1/2,0,0,\ldots,0)$, радиус шара $R=10$, критерий остановки по точности $\varepsilon=10^{-10}$, ограничение на количество итераций $Q=1000$, и произведем вычисления аналогично примеру из подраздела~\ref{eq:Problem}.

По завершении процесса вычисления и печати полученного результата, имеем значение оптимальной точки $x^*=(0,0,\ldots,0)$. Вычислительный процесс сошелся к решению за 403 итерации, т.е. останов произошел по достигнутой точности.

Покажем, что разработанная реализация алгоритма метода эллипсоидов решает такую задачу оптимизации быстрее, благодаря использованию многопоточности. Для этого проведем вычислительный эксперимент.

Сначала инструкцией

\lstinputlisting[firstline=229,lastline=231,firstnumber=229]{../../Practice/Tests/EllipsoidsMethodTest.cpp}

\noindent запретим программной реализации использование доступного аппаратного параллелизма. Запустим решение задачи (\ref{eq:LargeProblem})--(\ref{eq:LargeProblemConstraints}) и замерим время ее выполнения.

Затем активируем параллелизм командой

\lstinputlisting[firstline=243,lastline=243,firstnumber=243]{../../Practice/Tests/EllipsoidsMethodTest.cpp}

\noindent для использования в расчетах всех доступных аппаратно поддерживаемых потоков конкретной машины, и снова произведем расчеты и замерим время. После выполнения такой последовательности действий имеем следующие результаты.

Расчеты производились на двух машинах различной конфигурации. Первая из них была оборудована процессором Intel Pentium, который аппаратно поддерживал 2 потока, вторая -- Intel Core i7 с поддержкой 8 потоков. При тестовом запуске на первой машине время однопоточного вычисления составило $T_s^1=123.642$, а время вычисления с использованием двух потоков $T_m^1=71.9629$. В то же время на второй (более быстрой) машине обнаружились следующие результаты: $T_s^2=77.22$ и $T_m^2=28.1456$. Графическая интерпретация полученных результатов представлена на рисунке~\ref{fig:EmTime}.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{Figures/EmTime}
\caption{\label{fig:EmTime} Время выполнения оптимизации}
\end{figure}

Относительные коэффициенты ускорения для двух экспериментов составляют $k_1=T_s^1/T_m^1=123.642/71.9629=1.718$ и $k_2=T_s^2/T_m^2=77.22/28.1456=2.744$ соответственно. Поскольку разработанная реализация метода эллипсоидов опирается на класс матриц, поддерживающих распараллеливание операций, отсутствие линейного роста коэффициентов ускорения объясняется отсутствием такового у класса матриц. Так, увеличение числа потоков до 2 привело к уменьшению времени выполнения в $1.718$ раз, в то время как использование 8 одновременно выполняющихся потоков уменьшает общее время выполнения алгоритма лишь в $2.744$ раза. Экстраполируя рассуждения, предположим, что с большой вероятностью дальнейшее увеличение числа параллельных потоков будет сокращать время все меньше. Если и дальше продолжать увеличивать их количество, то время выполнения начнет не уменьшаться, а \textit{расти} и может даже превысить время однопоточной версии. Как уже было сказано, это будет происходить из-за дополнительных \textit{накладных расходов}, связанных с организацией параллелизма.

Тем не менее, возвращаясь к формулировке гипотезы~\ref{hyp:AboutTime} о соотношении времени, видим, что выдвинутые предположения \textbf{оправдались}: для разработанной реализации алгоритма метода эллипсоидов справедливо равенство $$F(t)=kf(t),$$ где $f(t)$ -- это время работы алгоритма, выполняемого в однопоточном режиме, $F(t)$ -- время работы параллельной реализации метода, $k$ -- коэффициент ускорения и $k>1$. Это справедливо для достаточно большой задачи оптимизации, в ходе решения которой возникает необходимость оперирования матрицами размерности $100\times 100$.