\newpage
\subsection{Тестирование}

Тестирование -- важная часть процесса разработки программных продуктов, поскольку ошибки -- это не случайное явление. Они -- обязательный спутник любого проекта.

Различают две формы тестирования. \emph{Тестирование методом прозрачного ящика} (white box testing), в котором испытатель имеет понятие о внутренней работе программы, и \emph{тестирование с алгоритмом типа черного ящика} (black box testing), когда программа тестируется без использования информации о ее реализации. Обе формы тестирования имеют важное значение для проектов, претендующих на попадание в категорию высококачественных. Чаще всего используется тестирование по принципу черного ящика, поскольку оно, как правило, моделирует типичное поведение пользователя. Например, при <<черном>> тестировании компоненты интерфейса можно рассматривать как кнопки. Если испытатель, щелкнув по кнопке, не увидел никакой реакции на свое действие, он делает вывод о том, что, очевидно, в программе есть ошибка.

Тестирование по принципу черного ящика не может охватить все аспекты испытываемого продукта. Современные программы слишком велики, чтобы реализовать имитацию щелчков по каждой кнопке, проверить все возможные варианты входных данных и выполнить все комбинации команд. Необходимость <<белого>> тестирования объясняется тем, что гораздо проще гарантировать тестовое покрытие множества неисправностей, если тесты будут написаны на уровне объекта или подсистемы. К тому же, зачастую <<белые>> тесты легче написать и автоматизировать, чем <<черные>>. В этой работе делается акцент на методах тестирования путем применения <<прозрачного ящика>>, поскольку программист может использовать эти методы еще во время разработки своей программы.

Единственный способ выявить ошибки в программе -- провести ее тестирование. Одним из самых важных видов тестирования с точки зрения разработчика является блочное, или поэлементное~\cite{Solter_Kleper2006}. Поэлементные тесты представляют собой программы, которые проверяют работоспособность класса или подсистемы. В идеальном варианте для каждой задачи низкого уровня должен существовать один или несколько тестов этого ранга.

Хорошо написанные тесты служат защитой во многих отношениях. Во-первых, они доказывают, что данная часть программы действительно работает должным образом. До тех пор, пока не будет получен код, который и в самом деле оправдывает существование тестируемого класса, его поведение можно считать неизвестным. Во-вторых, поэлементные тесты первыми подают сигнал тревоги, если после недавнего изменения что-то <<сломалось>>. В-третьих, используемые как часть общего процесса разработки, они заставляют разработчика устранять проблемы с самого начала. Если какой-либо участок кода вообще не контролируется с помощью блочных тестов, то в случае возникновения проблемы ее источник можно смело искать в этом участке. В-четвертых, поэлементные тесты позволяют испытать код до объединения с другим кодом. И наконец, поэлементные тесты показывают пример применения созданного кода.

Чем больше будет написано тестов, тем более обширным тестовым покрытием будет обладать код. Чем шире тестовое покрытие, тем меньше вероятность, что ошибки останутся невыявленными.

Существуют разные методики написания поэлементных тестов. Методология экстремального программирования (Extreme Programming methodology) предписывает своим сторонникам создавать тесты еще до написания кода. Теоретически предварительное написание тестов помогает четче сформулировать требования к компоненту и предложить систему показателей, которые могут быть использованы для определения момента завершения кода. Менее жесткий вариант состоит в проектировании тестов до кодирования, но в расчете на более позднюю их реализацию. В этом случае программист по-прежнему вынужден четко понимать требования, предъявляемые к модулю, но не обязан писать код, использующий еще несуществующие классы.

Код теста во многом зависит от типа используемой тестовой оболочки. В данной работе используется оболочка \textbf{CppUnit} -- это программный набор инструментов для модульного тестирования программ на языках программирования C/C++~\cite{Mohrhard}. Система разрабатывается с 2000 г. и публикуется под GNU LGPL.

Утилита запускает \emph{тесты}, сгруппированные в \emph{пакеты}. Результаты тестирования направляются в указанные фильтры, набор которых разнообразен: от простейшего подсчета пройденных либо не пройденных тестов до более продвинутых, поддерживающих XML-вывод, совместимый с дальнейшей интеграцией с системами отчетов.

Главной <<игровой фигурой>> оболочки \texttt{CppUnit} является класс \texttt{TestFixture}, который представляет собой логическую группу тестов. Оболочка \texttt{CppUnit} выполняет группу тестов в виде некоторого набора (тестового комплекта), который должен содержать информацию о том, какие тесты подлежат выполнению (в отличие от класса \texttt{TestFixture}, который просто логически группирует тесты). Чтобы выполнить набор тестов и увидеть результаты, необходим \textit{прогонщик тестов}. В оболочке \texttt{CppUnit} содержится несколько различных прогонщиков, которые действуют в различных средах (например, прогонщик \texttt{MFCRunner} предназначен для выполнения в программе, написанной с использованием библиотеки базовых классов Microsoft). Для текстовых сред используется прогонщик \texttt{TextRunner}. Для проверки утверждений и определения точного места, где они не выполняются, используется макрос \texttt{CPPUNIT\_ASSERT}.

Поскольку в данной работе разрабатывается класс, представляющий собой описание математического объекта (матрицы) в программе, для проверки его работоспособности видится естественным проведение как минимум следующих тестов.
\begin{itemize}
\item Основной тест сложения/умножения матриц.
\item Тест сложения/умножения матриц больших размерностей.
\item Тест сложения/умножения матриц, содержащих отрицательные элементы.
\item Тест сложения/умножения матриц, содержащих нулевые элементы.
\item Тест свойства коммутативности для операций сложения/умножения.
\end{itemize}