\subsection{Необходимость использования библиотеки GMP}

Библиотека GMP~\cite{Gmp} -- \textit{бесплатная (свободная)} библиотека для арифметики произвольной точности, выполняемой над знаковыми целыми, рациональными числами и числами с плавающей запятой. При этом практически не существует предела для точности вычислений, если не считать объем доступной памяти ЭВМ, на которой производятся вычисления. GMP имеет богатый набор функций, которые имеют стандартизированный интерфейс.

В основном GMP применяется в криптографических, научно-исследова\-тельских приложениях, приложениях, отвечающих за безопасность в сети Интернет, различных системах вычислительной алгебры и т.д.

Основными целевыми платформами GMP являются Unix-подобные системы, такие как GNU/Linux, Solaris, HP-UX, Mac OS X/Darwin, BSD, AIX и проч. Также поддерживается работа на Windows в 32 и 64-битном режимах. 

Библиотека GMP тщательно спроектирована для того, чтобы вычисления производились настолько быстро, насколько это возможно одновременно и для больших, и для малых операндов. Такая скорость возможна благодаря использованию машинных слов в качестве базового арифметического типа и быстрых алгоритмов, включающих высокооптимизированный ассемблерный код для большинства внутренних циклов для целого набора наиболее популярных современных центральных процессоров.

Первая версия GMP вышла в 1991 году. С тех пор библиотека непрерывно улучшается и поддерживается, обеспечивая выход новых версий примерно раз в год.

Начиная с версии 6, GMP распространяется одновременно под двумя лицензиями: GNU LGPL v3 и GNU GPL v2. Такое лицензирование позволяет использовать библиотеку бесплатно, изменять ее и публиковать результат.

Приведем численный пример, наглядно доказывающий необходимость использования библиотеки GMP для поддержки арифметики расширенной и произвольной точности. Рассмотрим следующий код, представленный в листинге~\ref{lst:precisionCpp}.

\lstinputlisting[label=lst:precisionCpp,caption={Исходный код примера},firstline=20,lastline=44]{../../Practice/Tests/MatrixTest.cpp}

В листинге используются объекты следующих классов:
\begin{enumerate}
\item \texttt{Matrix< Type >} представляет в программе матрицу, элементы которой имеют тип \texttt{Type};
\item \texttt{MatrixRandomFiller} предназначен для заполнения матрицы случайными значениями, равномерно распределенными на интервале $[0,1)$ (в процессе заполнения используются стандартный генератор псевдослучайных чисел \texttt{std::default\_random\_engine} и равномерное распределение \texttt{std::uniform\_real\_distribution} $P\left(i|a,b\right)=\frac{1}{b-a}$ с параметрами $a=0$, $b=1$);
\item \texttt{MatrixMultiplier} производит перемножение матриц;
\item \texttt{MatrixPrinter} отвечает за печать матриц.
\end{enumerate}

В строках 1--4 создаются и настраиваются следующие вспомогательные объекты: \texttt{filler}, \texttt{multiplier} и \texttt{printer}. \texttt{Printer} настраивается таким образом, чтобы осуществлять вывод в стандартный поток вывода \texttt{std::cout} и печатать матрицы с точностью до 20 знаков после запятой. В строках 6--7 задается размерность матриц, участвующих в данном примере. Затем происходит создание (строки 9--10), заполнение случайными значениями (строки 12--13) и печать (строки 15--16) двух операндов. В строке 19 осуществляется перемножение матриц \texttt{matrix\_a} и \texttt{matrix\_b} стандартным базовым алгоритмом (строка на столбец), результат которого сохраняется в объекте \texttt{matrix\_c}. В строке 22 также осуществляется перемножение операндов. Отличие от строки 19 состоит в том, что в данном случае для перемножения используется функция-член класса \texttt{Matrix}. Результат второго перемножения сохраняется в переменной \texttt{matrix\_d}. После этого осуществляется печать полученных результатов (строки 24--25).

Поскольку матрицы заполняются случайно, вывод программы зависит от конкретного запуска. В частности, возможен и такой вариант вывода.

$$
matrix\_a=\left(
\begin{array}{cc}
0.54846871850742517918 & 0.84412510404456542190 \\
0.95768018538410970564 & 0.80660421324152631328
\end{array}
\right),
$$

$$
matrix\_b=\left(
\begin{array}{cc}
0.96126112219013459814 & 0.79203852615307757112 \\
0.79959221481843290036 & 0.90154689901948148467
\end{array}
\right),
$$

$$
matrix\_c=\left(
\begin{array}{cc}
1.20217751736546674124 & 1.19542672538356331557 \\
1.56553517904925\underline{709736} & 1.48571112974158303643
\end{array}
\right),
$$

$$
matrix\_d=\left(
\begin{array}{cc}
1.20217751736546674124 & 1.19542672538356331557 \\
1.56553517904925\underline{687532} & 1.48571112974158303643
\end{array}
\right).
$$

Из приведенных значений элементов матриц хорошо видно, что для одних и тех же операндов результат перемножения, полученный вне и внутри класса \texttt{Matrix}, различен, начиная с 15-го знака после запятой. При этом популярный математический сервис WolframAlpha~\cite{WolframAlpha} для данных операндов выдает результат
$$
\left(
\begin{array}{cc}
1.2021775173654667\underline{500} & 1.1954267253835633\underline{424} \\
1.56553517904925\underline{70011} & 1.48571112974158\underline{29851}
\end{array}
\right),
$$
в котором наблюдаются отличия в знаках во всех элементах матрицы. Попытка провести аналогичные вычисления на языке программирования R приводит к результату, показанному в листинге~\ref{lst:precisionR}.

\lstset{
caption={Пример вычисления на языке R},
label={lst:precisionR}
}

\begin{lstlisting}
> options(digits=20)
> lhs = matrix( c( 0.54846871850742517918, 0.84412510404456542190,
                   0.95768018538410970564, 0.80660421324152631328 ),
                nrow=2, ncol=2, byrow=TRUE )
> rhs = matrix( c( 0.96126112219013459814, 0.79203852615307757112,
                   0.79959221481843290036, 0.90154689901948148467 ),
                nrow=2, ncol=2, byrow=TRUE )
> lhs %*% rhs
                      [,1]                  [,2]
[1,] 1.2021775173654667412 1.1954267253835633156
[2,] 1.5655351790492570974 1.4857111297415830364
\end{lstlisting}

Такое расхождение неслучайно. Если еще раз обратить внимание на листинг~\ref{lst:precisionCpp}, то можно увидеть, что в численном эксперименте участвуют матрицы, все элементы которых имеют тип \textbf{double}. Согласно спецификации языка C++\cite{Stroustrup2013}, для представления чисел с плавающей запятой существуют несколько типов данных, характеристики которых приведены в таблице~\ref{tab:cppFloatPointDataTypes}.

\begin{table}[h]
\caption{\label{tab:cppFloatPointDataTypes} Размер и диапазон чисел с плавающей запятой в языке C++}
\begin{tabularx}{\textwidth}{|l|c|X|}
\hline 
\textbf{Тип} & \textbf{Размер, байт} & \textbf{Допустимый диапазон значений} \\ 
\hline 
float & 4 & +/-- 3.4e +/-- 38 (точность $\sim\!7$ цифр) \\ 
\hline 
double & 8 & +/-- 1.7e +/-- 308 (точность $\sim\!15$ цифр) \\ 
\hline 
long double & 8 & +/-- 1.7e +/-- 308 (точность $\sim\!15$ цифр) \\ 
\hline 
\end{tabularx}
\end{table}

Согласно говорящим именам стандартных типов данных, а также информации из приведенной таблицы, тип \textbf{double} имеет точность, в два раза превышающую \textbf{float}. В общем случае \textbf{double} имеет 15--16 десятичных знаков точности, в то время как \textbf{float} только 7.

В численном эксперименте использовался тип данных \textbf{double}, что вызвало ошибку округления примерно на 15-м знаке после запятой. Соответственно, если применять тип данных с меньшей (\textbf{float}) или большей (\textbf{long double}) точностью, меняться будет только положение десятичного знака, на котором будет начинаться расхождение, но \textit{ошибка при этом не исчезнет}.

В такой ситуации разумным видится использование специализированных библиотек, таких как GMP, поддерживающих более точные вычисления. Именно свободный доступ, минимальные ограничения на использование, а также основная функция -- поддержка арифметики произвольной точности -- делают библиотеку GMP идеальным инструментом для использования в данной работе, особенность которой состоит в оперировании матрицами больших размерностей, что налагает дополнительные (более строгие) ограничения на точность полученного результата.