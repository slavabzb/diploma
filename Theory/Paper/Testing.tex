\newpage
\subsection{Тестирование}

Тестирование -- важная часть процесса разработки программных продуктов, поскольку ошибки -- это не случайное явление.

Различают две формы тестирования~\cite{Solter_Kleper2006}.
\begin{enumerate}
\item \emph{Тестирование методом прозрачного ящика} (white box testing), в котором испытатель имеет понятие о внутренней работе программы.
\item \emph{Тестирование с алгоритмом типа черного ящика} (black box testing), когда программа тестируется без использования информации о ее реализации.
\end{enumerate}

Обе формы тестирования имеют важное значение для проектов, претендующих на попадание в категорию высококачественных. Чаще всего используется тестирование по принципу черного ящика, поскольку оно, как правило, моделирует типичное поведение пользователя. Например, при <<черном>> тестировании компоненты интерфейса можно рассматривать как кнопки. Если испытатель, щелкнув по кнопке, не увидел никакой реакции на свое действие, он делает вывод о том, что, очевидно, в программе есть ошибка.

Тестирование по принципу черного ящика не может охватить все аспекты испытываемого продукта. Современные программы слишком велики, чтобы реализовать имитацию щелчков по каждой кнопке, проверить все возможные варианты входных данных и выполнить все комбинации команд. Необходимость <<белого>> тестирования объясняется тем, что гораздо проще гарантировать тестовое покрытие множества неисправностей, если тесты будут написаны на уровне объекта или подсистемы. К тому же, зачастую <<белые>> тесты легче написать и автоматизировать, чем <<черные>>. В этой работе делается акцент на методах тестирования путем применения <<прозрачного ящика>>, поскольку программист может использовать эти методы еще во время разработки своей программы.

Единственный способ выявить ошибки в программе -- провести ее тестирование. Одним из самых важных видов тестирования с точки зрения разработчика является блочное, или поэлементное~\cite{Solter_Kleper2006}. Поэлементные тесты представляют собой программы, которые проверяют работоспособность класса или подсистемы. В идеальном варианте для каждой задачи низкого уровня должен существовать один или несколько тестов этого ранга.

Хорошо написанные тесты служат защитой во многих отношениях.
\begin{enumerate}
\item Они доказывают, что данная часть программы действительно работает должным образом. До тех пор, пока не будет получен код, который и в самом деле оправдывает существование тестируемого класса, его поведение можно считать неизвестным.
\item Поэлементные тесты первыми подают сигнал тревоги, если после недавнего изменения возник дефект.
\item Используемые как часть общего процесса разработки, они заставляют разработчика устранять проблемы с самого начала. Если какой-либо участок кода вообще не контролируется с помощью блочных тестов, то в случае возникновения проблемы ее источник можно смело искать в этом участке.
\item Поэлементные тесты позволяют испытать код до объединения с другим кодом.
\item Поэлементные тесты показывают пример применения созданного кода.
\end{enumerate}

Увеличение количества написанных тестов влечет за собой расширение тестового покрытия кода и снижение вероятности невыявления ошибки.

Существуют разные методики написания поэлементных тестов~\cite{Solter_Kleper2006}. Методология экстремального программирования (Extreme Programming methodology) предписывает своим сторонникам создавать тесты еще до написания кода. Теоретически предварительное написание тестов помогает четче сформулировать требования к компоненту и предложить систему показателей, которые могут быть использованы для определения момента завершения кода. Менее жесткий вариант состоит в проектировании тестов до кодирования, но в расчете на более позднюю их реализацию. В этом случае программист по-прежнему вынужден четко понимать требования, предъявляемые к модулю, но не обязан писать код, использующий еще несуществующие классы.

Код теста во многом зависит от типа используемой тестовой оболочки. В данной работе используется оболочка \textbf{CppUnit} -- это программный набор инструментов для модульного тестирования программ на языках программирования C/C++~\cite{Mohrhard}. Система разрабатывается с 2000 г. и публикуется под GNU LGPL.

Оболочка запускает \emph{тесты}, сгруппированные в \emph{пакеты}. Результаты тестирования направляются в указанные фильтры, набор которых разнообразен: от простейшего подсчета пройденных либо не пройденных тестов до более продвинутых, поддерживающих XML-вывод, совместимый с дальнейшей интеграцией с системами отчетов.

Для того, чтобы понять, каким образом работает система тестирования \texttt{CppUnit}, рассмотрим, как спроектирован класс \texttt{MatrixTest}, основная задача которого -- проведение блочного тестирования класса \texttt{Matrix}.

Объявление класса происходит в заголовочном файле (полный код класса приведен в приложении~\ref{app:matrixTestSource}).

\lstset{style=cpp}
\lstset{caption=}
\lstinputlisting[firstline=22,lastline=23,firstnumber=22]{../../Practice/Tests/MatrixTest.h}

Класс \texttt{MatrixTest} наследуется от класса \texttt{TestFixture}, который представляет собой логическую группу тестов.

Оболочка \texttt{CppUnit} выполняет группу тестов в виде некоторого набора (тестового комплекта), который должен содержать информацию о том, какие тесты подлежат выполнению, а какие нет (в отличие от класса \texttt{TestFixture}, который просто логически группирует тесты). Для этой цели \texttt{CppUnit} предоставляет класс \texttt{TestSuite}, который содержит в себе произвольный набор тестов. Обычная практика использования класса \texttt{TestSuite} состоит в следующем. В классы тестов (например такие, как \texttt{MatrixTest}), добавляется специальный статический метод.
\begin{lstlisting}
public:
  static CppUnit::Test* suite()
  {
    ...  
  }
\end{lstlisting}
После чего, посредством вызова этого метода, происходит добавление произвольного количества тестов в тестовый набор и запуск этого набора на выполнение. Как можно заметить, это довольно рутинная, повторяющаяся для каждого нового теста, задача. Поэтому \texttt{CppUnit} предоставляет набор вспомогательных макросов, которые призваны упростить процесс создания наборов тестов.

Поскольку разрабатывается класс, представляющий собой описание математического объекта (матрицы) в программе, для проверки его работоспособности видится естественным проведение как минимум следующих тестов:
\begin{itemize}
\item тест сложения матриц;
\item тест умножения матриц;
\item тест транспонирования матриц;
\item тесты производительности.
\end{itemize}

В заголовочном файле класса \texttt{MatrixTest} происходит объявление перечисленных тестов.

\lstinputlisting[firstline=24,lastline=31,firstnumber=24]{../../Practice/Tests/MatrixTest.h}

Это один из примеров использования вспомогательных макросов. Такой код осуществляет автоматическое создание тестового набора \texttt{MatrixTest} и добавление тестов в набор для последующего выполнения.

Далее происходит объявление соответствующих методов класса.

\lstinputlisting[firstline=33,lastline=41,firstnumber=33]{../../Practice/Tests/MatrixTest.h}

Тест \texttt{testCrashDou\-bleType} не был добавлен в набор, потому что демонстрирует появление ошибки округления, возникающей при использовании типа \texttt{double} и проводит к систематическому непрохождению тестового набора. Исходный код этого теста уже был проанализирован (см. листинг~\ref{lst:precisionCpp} и комментарии к нему).

Чтобы выполнить набор тестов и увидеть результаты, необходим \textit{прогонщик тестов}. В оболочке \texttt{CppUnit} содержится несколько различных прогонщиков, которые действуют в различных средах (например, прогонщик \texttt{MFCRunner} предназначен для выполнения в программе, написанной с использованием библиотеки базовых классов Microsoft). Для текстовых сред используется прогонщик \texttt{TextRunner}. Ниже приводится код тела функции \texttt{main}, в котором проиходит создание всех основных объектов тестового окружения.

\lstinputlisting[firstline=14,lastline=33,firstnumber=14]{../../Practice/main.cpp}

В строке 16 создается объект \texttt{controller} класса \texttt{TestResult}, представляющий собой статистику прохождения тестов. Другие вспомогательные классы будут подключаться именно к нему. В строке 18 создается сборщик статистики. В строке 21 -- объект, следящий за ходом выполнения всего набора тестов. В строке 24 создается прогонщик тестов и запускается в строке 27. В строке 29 создается объект, отвечающий за печать результатов теста в совместимом с компилятором формате.

Рассмотрим структуру самих тестов, описанных в файле реализации. Для регистрации созданного набора тестов в системе используется такая строка.

\lstinputlisting[firstline=14,lastline=14,firstnumber=14]{../../Practice/Tests/MatrixTest.cpp}

Для проверки утверждений и определения точного места, где они не выполняются, используется макрос \texttt{CPPUNIT\_ASSERT}. Рассмотрим первый тест, где он применяется.

\lstinputlisting[firstline=49,lastline=63,firstnumber=49]{../../Practice/Tests/MatrixTest.cpp}

Это \emph{тест, проверяющий корректность сложения матриц}. В строках 51--55 с помощью уже известных объектов вспомогательных классов происходит создание и заполнение операндов, участвующих в тесте. В строке 58 осуществляется вычисление результата сложения двух операндов сторонним классом и сохранение этого результата в переменной \texttt{C}. В строке 60 сложение выполняет сам класс \texttt{Matrix}, сохраняя результат в переменную \texttt{D}. В строке 62 осуществляется формальная проверка на равенство двух независимо полученных результатов. В этой точке теста \textit{ожидается}, что значения этих результатов совпадут. Если окажется, что это не так, \texttt{CppUnit} сообщит о провале прохождения теста и укажет на эту точку, сообщив имя файла и номер строки.

\emph{Тест матричного умножения} во многом схож с первым тестом. Его исходный код приведен ниже.

\lstinputlisting[firstline=67,lastline=89,firstnumber=67]{../../Practice/Tests/MatrixTest.cpp}

Единственное отличие состоит в дополнительной проверке в строках 82--88 работы операции умножения матрицы на число.

\emph{Тест транспонирования} необходим для контроля правильности выполнения соответствующей матричной операции.

\lstinputlisting[firstline=93,lastline=116,firstnumber=93]{../../Practice/Tests/MatrixTest.cpp}

Рассмотрим тест подробнее. В строке 95 создается случайно заполненная матрица, и ее первоначальное значение в строке 98 дублируется. В строке 101 сторонний класс транспонирует исходную матрицу, сохраняя результат в переменной \texttt{matrix\_transp}. В строке 103 исходную матрицу транспонирует сам класс, после чего, в строке 105, результат операции сразу проверяется. В строке 110 производится проверка доступа по индексу. Смысл этой операции в том, чтобы убедиться в свойстве зеркальности операции транспонирования, а именно что $(i,j)$-й элемент исходной матрицы соответствует $(j,i)$-му элементу транспонированной. В строке 112 матрица транспонируется обратно, и в строке 114 проверяется на соответствие своему первоначальному значению. В строке 115 осуществляется еще одна проверка индексного доступа.

Тестовый набор содержит дополнительно тесты производительности, осуществляющие замеры времени работы разработанного класса. Их исходный код приведен в приложении~\ref{app:matrixTestSource}.