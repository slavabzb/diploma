\subsection{Необходимость использования библиотеки GMP}

Любое численное решение должно достигать определенной точности результата. А при оперировании матрицами большой размерности обеспечение требуемой точности становится еще более актуальным.

Один из способов обеспечения поддержки арифметики расширенной точности заключается в использовании готовых специализированных математических библиотек, таких, например, как GMP.

Библиотека GMP~\cite{Gmp} -- \textit{бесплатная (свободная)} библиотека для арифметики произвольной точности, выполняемой над знаковыми целыми, рациональными числами и числами с плавающей запятой. При этом практически не существует предела для точности вычислений, если не считать объем доступной памяти ЭВМ, на которой производятся вычисления. GMP имеет богатый набор функций, которые имеют стандартизированный интерфейс.

В основном GMP применяется в криптографических, научно-исследова\-тельских приложениях, приложениях, отвечающих за безопасность в сети Интернет, различных системах вычислительной алгебры и т.д.

Основными целевыми платформами GMP являются Unix-подобные системы, такие как GNU/Linux, Solaris, HP-UX, Mac OS X/Darwin, BSD, AIX и проч. Также поддерживается работа на Windows в 32 и 64-битном режимах. 

Библиотека GMP тщательно спроектирована для того, чтобы вычисления производились настолько быстро, насколько это возможно одновременно и для больших, и для малых операндов. Такая скорость возможна благодаря использованию машинных слов в качестве базового арифметического типа и быстрых алгоритмов, включающих высокооптимизированный ассемблерный код для большинства внутренних циклов для целого набора наиболее популярных современных центральных процессоров.

Первая версия GMP вышла в 1991 году. С тех пор библиотека непрерывно улучшается и поддерживается, обеспечивая выход новых версий примерно раз в год.

Начиная с версии 6, GMP распространяется одновременно под двумя лицензиями: GNU LGPL v3 и GNU GPL v2. Такое лицензирование позволяет использовать библиотеку бесплатно, изменять ее и публиковать результат.

Приведем численный пример, наглядно доказывающий необходимость использования библиотеки GMP для поддержки арифметики расширенной и произвольной точности. Рассмотрим следующий код, представленный в листинге~\ref{lst:precisionCpp}.

\lstinputlisting[label=lst:precisionCpp,caption={Исходный код примера},firstline=20,lastline=46]{../../Practice/Tests/MatrixTest.cpp}

В листинге используются объекты следующих классов:
\begin{enumerate}
\item \texttt{Matrix< Type >} представляет в программе матрицу, элементы которой имеют тип \texttt{Type};
\item \texttt{MatrixRandomFiller} предназначен для заполнения матрицы случайными значениями, равномерно распределенными на интервале $[0,1)$ (в процессе заполнения используются стандартный генератор псевдослучайных чисел \texttt{std::default\_random\_engine} и равномерное распределение \texttt{std::uniform\_real\_distribution} $P\left(i|a,b\right)=\frac{1}{b-a}$ с параметрами $a=0$, $b=1$);
\item \texttt{MatrixMultiplier} производит перемножение матриц;
\item \texttt{MatrixPrinter} отвечает за печать матриц.
\end{enumerate}

В строках 3--4 задается размерность матриц, участвующих в данном примере. Затем происходит создание (строки 6--7), заполнение случайными значениями (строки 10--11) и печать (строки 15--16) двух операндов. Заметим, что \texttt{matrix\_printer} настраивается таким образом, чтобы осуществлять вывод в стандартный поток вывода \texttt{std::cout} и печатать матрицы с точностью до 20 знаков после запятой. В строке 20 осуществляется умножение матриц \texttt{A} и \texttt{B} стандартным базовым алгоритмом (строка на столбец), результат которого сохраняется в объекте \texttt{C}. В строке 23 также осуществляется умножение операндов. Отличие от строки 20 состоит в том, что в данном случае для умножения используется функция-член класса \texttt{Matrix}. Результат второго умножения сохраняется в переменной \texttt{D}. После этого осуществляется печать полученных результатов (строки 25--26).

Поскольку матрицы заполняются случайным образом, вывод программы зависит от конкретного запуска. В частности, возможен и такой вариант вывода.

$$
\mbox{\texttt{A}}=\left(
\begin{array}{cc}
0.54846871850742517918 & 0.84412510404456542190 \\
0.95768018538410970564 & 0.80660421324152631328
\end{array}
\right),
$$

$$
\mbox{\texttt{B}}=\left(
\begin{array}{cc}
0.96126112219013459814 & 0.79203852615307757112 \\
0.79959221481843290036 & 0.90154689901948148467
\end{array}
\right),
$$

$$
\mbox{\texttt{C}}=\left(
\begin{array}{cc}
1.20217751736546674124 & 1.19542672538356331557 \\
1.56553517904925\underline{709736} & 1.48571112974158303643
\end{array}
\right),
$$

$$
\mbox{\texttt{D}}=\left(
\begin{array}{cc}
1.20217751736546674124 & 1.19542672538356331557 \\
1.56553517904925\underline{687532} & 1.48571112974158303643
\end{array}
\right).
$$

Из приведенных значений элементов матриц хорошо видно, что для одних и тех же операндов результат перемножения, полученный вне и внутри класса \texttt{Matrix}, различен, начиная с 15-го знака после запятой. 

Популярный математический сервис WolframAlpha~\cite{WolframAlpha} для данных операндов выдает результат
$$
\left(
\begin{array}{cc}
1.2021775173654667\underline{500} & 1.1954267253835633\underline{424} \\
1.56553517904925\underline{70011} & 1.48571112974158\underline{29851}
\end{array}
\right),
$$
в котором наблюдаются отличия в знаках во всех элементах матрицы. Попытка провести аналогичные вычисления на языке программирования R приводит к результату, показанному в листинге~\ref{lst:precisionR}.

\begin{lstlisting}[caption={Пример вычисления на языке R},label={lst:precisionR}]
> options(digits=20)
> lhs = matrix( c( 0.54846871850742517918, 0.84412510404456542190,
                   0.95768018538410970564, 0.80660421324152631328 ),
                nrow=2, ncol=2, byrow=TRUE )
> rhs = matrix( c( 0.96126112219013459814, 0.79203852615307757112,
                   0.79959221481843290036, 0.90154689901948148467 ),
                nrow=2, ncol=2, byrow=TRUE )
> lhs %*% rhs
                      [,1]                  [,2]
[1,] 1.2021775173654667412 1.1954267253835633156
[2,] 1.5655351790492570974 1.4857111297415830364
\end{lstlisting}

Такое расхождение неслучайно. В численном эксперименте (см. листинг~\ref{lst:precisionCpp}) участвуют матрицы, все элементы которых имеют тип \texttt{double}. В языке C++ для представления чисел с плавающей запятой существуют несколько стандартных типов данных~\cite{Stroustrup2013}. Характеристики этих типов приведены в таблице~\ref{tab:cppFloatPointDataTypes}.

\begin{table}[h]
\caption{\label{tab:cppFloatPointDataTypes} Размер и диапазон чисел с плавающей запятой в языке C++}
\begin{tabularx}{\textwidth}{|l|c|X|}
\hline 
\textbf{Тип} & \textbf{Размер, байт} & \textbf{Допустимый диапазон значений} \\ 
\hline 
float & 4 & +/-- 3.4e +/-- 38 (точность $\sim\!7$ цифр) \\ 
\hline 
double & 8 & +/-- 1.7e +/-- 308 (точность $\sim\!15$ цифр) \\ 
\hline 
long double & 8 & +/-- 1.7e +/-- 308 (точность $\sim\!15$ цифр) \\ 
\hline 
\end{tabularx}
\end{table}

Согласно информации из таблицы~\ref{tab:cppFloatPointDataTypes}, тип \texttt{double} имеет точность, в два раза превышающую \texttt{float}. В общем случае \texttt{double} имеет 15--16 десятичных знаков точности, в то время как \texttt{float} только 7.

В численном эксперименте использовался тип данных \texttt{double}, что вызвало ошибку округления примерно на 15-м знаке после запятой. Соответственно, если применять тип данных с меньшей (\texttt{float}) или большей (\texttt{long double}) точностью, меняться будет только положение десятичного знака, на котором будет начинаться расхождение, но \textit{ошибка при этом не исчезнет}.

В такой ситуации разумным видится использование специализированных библиотек, таких как GMP, поддерживающих более точные вычисления. Именно свободный доступ, минимальные ограничения на использование, а также основная функция -- поддержка арифметики произвольной точности -- делают библиотеку GMP идеальным инструментом для использования в данной работе, особенность которой состоит в оперировании матрицами больших размерностей, что налагает дополнительные (более строгие) ограничения на точность полученного результата.